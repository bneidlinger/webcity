var Z=Object.defineProperty;var tt=(P,t,o)=>t in P?Z(P,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):P[t]=o;var k=(P,t,o)=>tt(P,typeof t!="symbol"?t+"":t,o);function H(P){return function(){let t=P+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}class et{constructor(){k(this,"segments",new Map);k(this,"intersections",new Map);k(this,"nextSegmentId",0);k(this,"nextIntersectionId",0);k(this,"SNAP_THRESHOLD",10);k(this,"INTERSECTION_THRESHOLD",2)}clear(){this.segments.clear(),this.intersections.clear(),this.nextSegmentId=0,this.nextIntersectionId=0}addSegment(t,o,e,n){const s=this.nextSegmentId++,i={id:s,start:{...t},end:{...o},width:e,class:n},r=this.findIntersections(i),c=this.splitSegmentAtPoints(i,r);for(const a of c)this.segments.set(a.id,a);return this.updateIntersections(c,r),this.handleEndpointSnapping(c),s}findIntersections(t){const o=[];for(const[e,n]of this.segments){const s=this.lineIntersection(t.start,t.end,n.start,n.end);if(s){const i=this.distance(s,t.start),r=this.distance(s,t.end),c=this.distance(s,n.start),a=this.distance(s,n.end);i>this.INTERSECTION_THRESHOLD&&r>this.INTERSECTION_THRESHOLD&&c>this.INTERSECTION_THRESHOLD&&a>this.INTERSECTION_THRESHOLD&&o.push({point:s,segmentId:e})}}return o}lineIntersection(t,o,e,n){const s=(t.x-o.x)*(e.y-n.y)-(t.y-o.y)*(e.x-n.x);if(Math.abs(s)<.001)return null;const i=((t.x-e.x)*(e.y-n.y)-(t.y-e.y)*(e.x-n.x))/s,r=-((t.x-o.x)*(t.y-e.y)-(t.y-o.y)*(t.x-e.x))/s;return i>=0&&i<=1&&r>=0&&r<=1?{x:t.x+i*(o.x-t.x),y:t.y+i*(o.y-t.y)}:null}splitSegmentAtPoints(t,o){if(o.length===0)return[t];const e=o.sort((r,c)=>{const a=this.distance(t.start,r.point),h=this.distance(t.start,c.point);return a-h}),n=[];let s=t.start,i=0;for(const r of e){const c={id:t.id+i*.001,start:{...s},end:{...r.point},width:t.width,class:t.class};n.push(c),s=r.point,i++,this.splitExistingSegment(r.segmentId,r.point)}return n.push({id:t.id+i*.001,start:{...s},end:{...t.end},width:t.width,class:t.class}),n}splitExistingSegment(t,o){const e=this.segments.get(t);if(!e)return;const n=this.distance(o,e.start),s=this.distance(o,e.end);if(n>this.INTERSECTION_THRESHOLD&&s>this.INTERSECTION_THRESHOLD){this.segments.delete(t);const i={id:t,start:e.start,end:{...o},width:e.width,class:e.class},r={id:this.nextSegmentId++,start:{...o},end:e.end,width:e.width,class:e.class};this.segments.set(i.id,i),this.segments.set(r.id,r)}}updateIntersections(t,o){const e=new Set,n=new Map;for(const s of t){const i=`${Math.round(s.start.x)},${Math.round(s.start.y)}`,r=`${Math.round(s.end.x)},${Math.round(s.end.y)}`;e.add(i),e.add(r),n.set(i,s.start),n.set(r,s.end)}for(const s of o){const i=`${Math.round(s.point.x)},${Math.round(s.point.y)}`;e.add(i),n.set(i,s.point)}for(const[s,i]of n)this.createOrUpdateIntersection(i)}createOrUpdateIntersection(t){const o=[];let e=0;for(const[s,i]of this.segments){const r=this.distance(t,i.start),c=this.distance(t,i.end);(r<this.INTERSECTION_THRESHOLD||c<this.INTERSECTION_THRESHOLD)&&(o.push(s),e=Math.max(e,i.width))}if(o.length<2)return;let n;for(const[s,i]of this.intersections)if(this.distance(i.position,t)<this.INTERSECTION_THRESHOLD){n=i;break}if(n)n.connectedSegments=o,n.type=this.getIntersectionType(o.length),n.radius=e*.75;else{const s={id:this.nextIntersectionId++,position:{...t},connectedSegments:o,type:this.getIntersectionType(o.length),angle:this.calculateAverageAngle(o,t),radius:e*.75};this.intersections.set(s.id,s)}}handleEndpointSnapping(t){for(const o of t)for(const[e,n]of this.segments){if(n.id===o.id)continue;const s=this.distance(o.start,n.start),i=this.distance(o.start,n.end);s<this.SNAP_THRESHOLD?o.start={...n.start}:i<this.SNAP_THRESHOLD&&(o.start={...n.end});const r=this.distance(o.end,n.start),c=this.distance(o.end,n.end);r<this.SNAP_THRESHOLD?o.end={...n.start}:c<this.SNAP_THRESHOLD&&(o.end={...n.end})}}getIntersectionType(t){switch(t){case 2:return"end";case 3:return"T";case 4:return"cross";default:return"complex"}}calculateAverageAngle(t,o){let e=0,n=0;for(const s of t){const i=this.segments.get(s);if(!i)continue;const c=this.distance(o,i.start)<this.INTERSECTION_THRESHOLD?Math.atan2(i.end.y-i.start.y,i.end.x-i.start.x):Math.atan2(i.start.y-i.end.y,i.start.x-i.end.x);e+=c,n++}return n>0?e/n:0}distance(t,o){const e=o.x-t.x,n=o.y-t.y;return Math.sqrt(e*e+n*n)}getSegments(){return Array.from(this.segments.values())}getIntersections(){return Array.from(this.intersections.values())}generateIntersectionGeometry(t){const o=[];for(const e of t.connectedSegments){const n=this.segments.get(e);n&&o.push(n)}switch(t.type){case"T":return this.generateTJunctionGeometry(t,o);case"cross":return this.generateCrossIntersectionGeometry(t,o);case"complex":return this.generateComplexIntersectionGeometry(t,o);default:return this.generateSimpleIntersectionGeometry(t,o)}}generateTJunctionGeometry(t,o){const e=[],n=[],s=[],i=t.radius,r=t.position,c=16;e.push(r.x,.22,r.y),s.push(.5,.5);for(let a=0;a<=c;a++){const h=a/c*Math.PI*2,l=r.x+Math.cos(h)*i,g=r.y+Math.sin(h)*i;e.push(l,.22,g),s.push(.5+Math.cos(h)*.5,.5+Math.sin(h)*.5)}for(let a=0;a<c;a++)n.push(0,a+1,a+2);return{vertices:new Float32Array(e),indices:new Uint32Array(n),uvs:new Float32Array(s)}}generateCrossIntersectionGeometry(t,o){const e=[],n=[],s=[],i=t.radius,r=t.position,c=i*.3,a=i,h=[{x:r.x-a,y:r.y-a},{x:r.x+a,y:r.y-a},{x:r.x+a,y:r.y+a},{x:r.x-a,y:r.y+a}];e.push(r.x,.22,r.y),s.push(.5,.5);for(let l=0;l<4;l++){const g=h[l],d=l*Math.PI/2,u=8;for(let f=0;f<=u;f++){const p=d+f/u*Math.PI/2,x=g.x+Math.cos(p)*c,m=g.y+Math.sin(p)*c;e.push(x,.22,m);const I=(x-r.x)/(i*2)+.5,M=(m-r.y)/(i*2)+.5;s.push(I,M)}const y=1+l*(u+1);for(let f=0;f<u;f++)n.push(0,y+f,y+f+1)}return{vertices:new Float32Array(e),indices:new Uint32Array(n),uvs:new Float32Array(s)}}generateComplexIntersectionGeometry(t,o){const e=[],n=[],s=[],i=t.radius*1.2,r=t.position,c=32;e.push(r.x,.22,r.y),s.push(.5,.5);for(let a=0;a<=c;a++){const h=a/c*Math.PI*2,l=r.x+Math.cos(h)*i,g=r.y+Math.sin(h)*i;e.push(l,.22,g),s.push(.5+Math.cos(h)*.5,.5+Math.sin(h)*.5)}for(let a=0;a<c;a++)n.push(0,a+1,a+2);return{vertices:new Float32Array(e),indices:new Uint32Array(n),uvs:new Float32Array(s)}}generateSimpleIntersectionGeometry(t,o){const e=[],n=[],s=[],i=t.radius*.5,r=t.position,c=12;e.push(r.x,.22,r.y),s.push(.5,.5);for(let a=0;a<=c;a++){const h=a/c*Math.PI*2,l=r.x+Math.cos(h)*i,g=r.y+Math.sin(h)*i;e.push(l,.22,g),s.push(.5+Math.cos(h)*.5,.5+Math.sin(h)*.5)}for(let a=0;a<c;a++)n.push(0,a+1,a+2);return{vertices:new Float32Array(e),indices:new Uint32Array(n),uvs:new Float32Array(s)}}}const nt=20,Y=15,st=10,N={highway:24,avenue:16,street:12,local:8},_={residential:{min:15,max:30},commercial:{min:20,max:40},industrial:{min:30,max:60},none:{min:0,max:0}},W={low:2,medium:1.5,high:1};function C(P,t){const o=parseInt(P.substring(0,4));return o<=1900?"dirt":o<=1930?t==="highway"||t==="avenue"?"cobblestone":"dirt":o<=1950?t==="local"?"dirt":"cobblestone":o<=1990?t==="local"?"cobblestone":"asphalt":t==="highway"?"concrete":"asphalt"}class ot{constructor(t,o,e=50){k(this,"cellSize");k(this,"grid");k(this,"width");k(this,"height");this.width=t,this.height=o,this.cellSize=e,this.grid=new Map}getKey(t,o){const e=Math.floor(t/this.cellSize),n=Math.floor(o/this.cellSize);return`${e},${n}`}insert(t,o,e){const n=this.getKey(o,e);this.grid.has(n)||this.grid.set(n,[]),this.grid.get(n).push(t)}getNearby(t,o,e){const n=[],s=Math.ceil(e/this.cellSize),i=Math.floor(t/this.cellSize),r=Math.floor(o/this.cellSize);for(let c=-s;c<=s;c++)for(let a=-s;a<=s;a++){const h=`${i+c},${r+a}`,l=this.grid.get(h);l&&n.push(...l)}return n}clear(){this.grid.clear()}remove(t,o,e){const n=this.getKey(o,e),s=this.grid.get(n);if(s){const i=s.indexOf(t);i!==-1&&(s.splice(i,1),s.length===0&&this.grid.delete(n))}}}class it{constructor(t,o,e){k(this,"nodes");k(this,"edges");k(this,"spatialIndex");k(this,"nextNodeId",0);k(this,"nextEdgeId",0);k(this,"rng");this.nodes=new Map,this.edges=new Map,this.spatialIndex=new ot(t,o),this.rng=e}addNode(t,o){const e=this.spatialIndex.getNearby(t,o,Y);for(const i of e){const r=this.nodes.get(i);if(r&&this.distance(r.pos,{x:t,y:o})<Y)return i}const n=this.nextNodeId++,s={id:n,pos:{x:t,y:o},edges:[],isIntersection:!1};return this.nodes.set(n,s),this.spatialIndex.insert(n,t,o),n}addEdge(t,o,e,n){const s=this.nodes.get(t),i=this.nodes.get(o);if(!s||!i)return null;for(const h of s.edges){const l=this.edges.get(h);if(l&&(l.nodeB===o||l.nodeA===o))return h}if(!this.checkMinimumAngle(t,o,30))return null;const r=this.nextEdgeId++,c=this.distance(s.pos,i.pos),a={id:r,nodeA:t,nodeB:o,roadClass:e,material:n,width:N[e],length:c};return this.edges.set(r,a),s.edges.push(r),i.edges.push(r),s.edges.length>1&&(s.isIntersection=!0),i.edges.length>1&&(i.isIntersection=!0),r}distance(t,o){const e=o.x-t.x,n=o.y-t.y;return Math.sqrt(e*e+n*n)}angle(t,o){return Math.atan2(o.y-t.y,o.x-t.x)}angleDifference(t,o){let e=Math.abs(o-t);return e>Math.PI&&(e=2*Math.PI-e),e}removeNode(t){const o=this.nodes.get(t);if(o){this.spatialIndex.remove(t,o.pos.x,o.pos.y);for(const e of o.edges)this.removeEdge(e);this.nodes.delete(t)}}removeEdge(t){const o=this.edges.get(t);if(!o)return;const e=this.nodes.get(o.nodeA),n=this.nodes.get(o.nodeB);if(e){const s=e.edges.indexOf(t);s!==-1&&e.edges.splice(s,1),e.edges.length<=1&&(e.isIntersection=!1)}if(n){const s=n.edges.indexOf(t);s!==-1&&n.edges.splice(s,1),n.edges.length<=1&&(n.isIntersection=!1)}this.edges.delete(t)}checkMinimumAngle(t,o,e){const n=this.nodes.get(t),s=this.nodes.get(o);if(!n||!s)return!1;const i=e*Math.PI/180,r=this.angle(n.pos,s.pos);for(const c of n.edges){const a=this.edges.get(c);if(!a)continue;const h=a.nodeA===t?a.nodeB:a.nodeA,l=this.nodes.get(h);if(!l)continue;const g=this.angle(n.pos,l.pos);if(this.angleDifference(r,g)<i)return!1}return!0}getTypedArrays(){const t=this.nodes.size,o=this.edges.size,e=new Float32Array(t*2),n=8,s=new Uint32Array(t*(1+n)),i=new Uint32Array(o*5),r=new Float32Array(o*6);let c=0;const a=new Map;for(const[l,g]of this.nodes){a.set(l,c),e[c*2]=g.pos.x,e[c*2+1]=g.pos.y;const d=c*(1+n);s[d]=Math.min(g.edges.length,n);for(let u=0;u<Math.min(g.edges.length,n);u++)s[d+1+u]=g.edges[u];c++}let h=0;for(const[l,g]of this.edges){const d=this.nodes.get(g.nodeA),u=this.nodes.get(g.nodeB);if(!d||!u)continue;const y=h*5;i[y]=a.get(g.nodeA)||0,i[y+1]=a.get(g.nodeB)||0,i[y+2]=this.roadClassToInt(g.roadClass),i[y+3]=this.materialToInt(g.material),i[y+4]=g.width;const f=h*6;r[f]=d.pos.x,r[f+1]=d.pos.y,r[f+2]=u.pos.x,r[f+3]=u.pos.y,r[f+4]=g.width,r[f+5]=this.roadClassToInt(g.roadClass),h++}return{nodePositions:e,nodeConnections:s,edgeData:i,roadSegments:r}}roadClassToInt(t){return{highway:0,avenue:1,street:2,local:3}[t]}materialToInt(t){return{dirt:0,cobblestone:1,asphalt:2,concrete:3}[t]}getRoadSegments(){const t=[];for(const o of this.edges.values()){const e=this.nodes.get(o.nodeA),n=this.nodes.get(o.nodeB);!e||!n||t.push({start:{...e.pos},end:{...n.pos},class:o.roadClass,material:o.material,width:o.width})}return t}clear(){this.nodes.clear(),this.edges.clear(),this.spatialIndex.clear(),this.nextNodeId=0,this.nextEdgeId=0}}class rt{constructor(t,o){k(this,"network");k(this,"config");k(this,"rng");this.config=t,this.rng=o,this.network=new it(t.bounds.width,t.bounds.height,o)}generate(){return this.network.clear(),console.log("[RoadGen] Network initialized for manual road drawing"),this.network}generateCenters(){const t=[],o=Math.min(this.config.bounds.width,this.config.bounds.height)*.15;if(this.config.centerCount===1)t.push({x:this.config.bounds.width*(.4+this.rng()*.2),y:this.config.bounds.height*(.4+this.rng()*.2)});else{const e=Math.min(this.config.bounds.width,this.config.bounds.height)/(this.config.centerCount+1);for(let n=0;n<this.config.centerCount;n++){let s=0,i=!1,r={x:0,y:0};for(;!i&&s<30;){r={x:o+this.rng()*(this.config.bounds.width-2*o),y:o+this.rng()*(this.config.bounds.height-2*o)},i=!0;for(const c of t)if(this.distance(c,r)<e){i=!1;break}s++}i&&t.push(r)}}return t}generateRadialRoads(t){for(const o of t){const e=this.network.addNode(o.x,o.y),s=5+Math.floor(this.config.density*4)+Math.floor(this.rng()*3),i=this.rng()*Math.PI*2,r=[];for(let c=0;c<s;c++){const a=Math.PI*(3-Math.sqrt(5)),h=i+c*a,l=(this.rng()-.5)*.4;let g=h+l,d=!1;for(const m of r)if(Math.abs(this.angleDifference(g,m))<this.config.minIntersectionAngle*Math.PI/180){d=!0;break}if(d)continue;r.push(g);const y=1-this.distance(o,{x:this.config.bounds.width/2,y:this.config.bounds.height/2})/(Math.max(this.config.bounds.width,this.config.bounds.height)/2),f=(this.config.bounds.width+this.config.bounds.height)/4*(.5+y*.5+this.rng()*.3),p=this.generateOrganicPath(o,{x:o.x+Math.cos(g)*f,y:o.y+Math.sin(g)*f},"radial");let x=e;for(let m=1;m<p.length;m++){const I=this.clipToBounds(p[m]),M=this.network.addNode(I.x,I.y),z=this.distance(o,I),T=z<100?"avenue":z<300?"street":"local",A=C(this.config.era,T);this.network.addEdge(x,M,T,A),x=M}}}}generateHighwayNetwork(t){if(!(t.length<2)){for(let o=0;o<t.length;o++)for(let e=o+1;e<t.length;e++){const n=this.generateOrganicPath(t[o],t[e],"highway");this.createRoadFromPath(n,"highway")}for(const o of t.slice(0,2)){const e=200+this.rng()*100,n=16,s=[];for(let i=0;i<n;i++){const r=i/n*Math.PI*2,c=e+(this.rng()-.5)*30,a=o.x+Math.cos(r)*c,h=o.y+Math.sin(r)*c;if(a>=0&&a<=this.config.bounds.width&&h>=0&&h<=this.config.bounds.height){const l=this.network.addNode(a,h);s.push(l)}}for(let i=0;i<s.length;i++){const r=(i+1)%s.length,c=C(this.config.era,"highway");this.network.addEdge(s[i],s[r],"highway",c)}}}}generateAdaptiveGrid(){const t=(this.config.blockSizeMin+this.config.blockSizeMax)/2,o=(this.config.blockSizeMax-this.config.blockSizeMin)/2,e=this.findEmptyRegions();for(const n of e){const s=this.calculateRegionOrientation(n);this.generateAlignedGrid(n,s,t,o)}}generateLocalRoads(){Array.from(this.network.nodes.values());const t=this.config.blockSizeMax*1.5;for(let o=50;o<this.config.bounds.width-50;o+=t/2)for(let e=50;e<this.config.bounds.height-50;e+=t/2)this.network.spatialIndex.getNearby(o,e,t).length===0&&this.generateLocalCluster({x:o,y:e},t/2)}generateOrganicPath(t,o,e){const n=[t],s=this.distance(t,o),i=Math.ceil(e==="highway"?s/150:s/80);for(let r=1;r<i;r++){const c=r/i;let a=t.x+(o.x-t.x)*c,h=t.y+(o.y-t.y)*c;const l=this.angle(t,o)+Math.PI/2,g=e==="highway"?15:25,d=Math.sin(c*Math.PI)*g*(this.rng()-.5)*2;a+=Math.cos(l)*d,h+=Math.sin(l)*d,e!=="highway"&&(a+=(this.rng()-.5)*10,h+=(this.rng()-.5)*10),n.push({x:a,y:h})}return n.push(o),n}createRoadFromPath(t,o){if(t.length<2)return;const e=C(this.config.era,o);let n=this.network.addNode(t[0].x,t[0].y);for(let s=1;s<t.length;s++){const i=this.network.addNode(t[s].x,t[s].y);this.network.addEdge(n,i,o,e),n=i}}findEmptyRegions(){const t=[],o=this.config.blockSizeMax*2,e=o;for(let n=o;n<this.config.bounds.width-o;n+=e)for(let s=o;s<this.config.bounds.height-o;s+=e){const i=this.network.spatialIndex.getNearby(n,s,o);if(i.length<3){let r=o;for(const c of i){const a=this.network.nodes.get(c);if(a){const h=this.distance({x:n,y:s},a.pos);r=Math.min(r,h*.8)}}r>this.config.blockSizeMin&&t.push({center:{x:n,y:s},radius:r})}}return t}calculateRegionOrientation(t){const o=this.network.spatialIndex.getNearby(t.center.x,t.center.y,t.radius*2);if(o.length<2)return 0;let e=0,n=0;for(const s of o){const i=this.network.nodes.get(s);if(i)for(const r of i.edges){const c=this.network.edges.get(r);if(!c)continue;const a=c.nodeA===s?c.nodeB:c.nodeA,h=this.network.nodes.get(a);if(!h)continue;const l=this.angle(i.pos,h.pos);e+=l,n++}}return n>0?e/n:0}generateAlignedGrid(t,o,e,n){const s=Math.cos(o),i=Math.sin(o),r=new Map,c=Math.floor(t.radius*2/e);for(let a=-c/2;a<=c/2;a++)for(let h=-c/2;h<=c/2;h++){const l=a*e+(this.rng()-.5)*n,g=h*e+(this.rng()-.5)*n,d=t.center.x+l*s-g*i,u=t.center.y+l*i+g*s;if(this.distance(t.center,{x:d,y:u})>t.radius||d<0||d>this.config.bounds.width||u<0||u>this.config.bounds.height||this.network.spatialIndex.getNearby(d,u,nt).length>0)continue;const p=this.network.addNode(d,u);r.set(`${a},${h}`,p)}for(const[a,h]of r){const[l,g]=a.split(",").map(Number),d=[[`${l+1},${g}`,"horizontal"],[`${l},${g+1}`,"vertical"]];for(const[u,y]of d)if(r.has(u)){const f=r.get(u),p=(Math.abs(l)+Math.abs(g))%4===0?"street":"local",x=C(this.config.era,p);this.network.addEdge(h,f,p,x)}}}generateLocalCluster(t,o){const e=3+Math.floor(this.rng()*3),n=this.network.addNode(t.x,t.y);for(let s=0;s<e;s++){const i=s/e*Math.PI*2+this.rng()*.5,r=o*(.5+this.rng()*.5),c=t.x+Math.cos(i)*r,a=t.y+Math.sin(i)*r;if(c>=0&&c<=this.config.bounds.width&&a>=0&&a<=this.config.bounds.height){const h=this.network.addNode(c,a),l=C(this.config.era,"local");this.network.addEdge(n,h,"local",l)}}}connectIsolatedSections(){const t=this.findConnectedComponents();if(t.length<=1)return;const o=t.reduce((e,n)=>n.size>e.size?n:e);for(const e of t){if(e===o)continue;let n=1/0,s=null;for(const i of e){const r=this.network.nodes.get(i);if(r)for(const c of o){const a=this.network.nodes.get(c);if(!a)continue;const h=this.distance(r.pos,a.pos);h<n&&(n=h,s=[i,c])}}if(s&&n<this.config.bounds.width/4){const i=C(this.config.era,"street");this.network.addEdge(s[0],s[1],"street",i)}}}findConnectedComponents(){const t=new Set,o=[];for(const[e]of this.network.nodes)if(!t.has(e)){const n=new Set;this.dfsComponent(e,t,n),o.push(n)}return o}dfsComponent(t,o,e){o.add(t),e.add(t);const n=this.network.nodes.get(t);if(n)for(const s of n.edges){const i=this.network.edges.get(s);if(!i)continue;const r=i.nodeA===t?i.nodeB:i.nodeA;o.has(r)||this.dfsComponent(r,o,e)}}mergeCloseIntersections(){const t=Array.from(this.network.nodes.values()),o=new Map;for(let e=0;e<t.length;e++){const n=t[e];if(!o.has(n.id))for(let s=e+1;s<t.length;s++){const i=t[s];if(o.has(i.id))continue;this.distance(n.pos,i.pos)<st&&n.isIntersection&&i.isIntersection&&o.set(i.id,n.id)}}for(const[e,n]of o)this.mergeNodes(e,n)}mergeNodes(t,o){const e=this.network.nodes.get(t),n=this.network.nodes.get(o);if(!(!e||!n)){for(const s of e.edges){const i=this.network.edges.get(s);i&&(i.nodeA===t&&(i.nodeA=o),i.nodeB===t&&(i.nodeB=o),n.edges.includes(s)||n.edges.push(s))}this.network.nodes.delete(t),n.edges.length>1&&(n.isIntersection=!0)}}optimizeIntersectionAngles(){const t=Array.from(this.network.nodes.values()).filter(o=>o.isIntersection&&o.edges.length>2);for(const o of t){const e=[];for(const i of o.edges){const r=this.network.edges.get(i);if(!r)continue;const c=r.nodeA===o.id?r.nodeB:r.nodeA,a=this.network.nodes.get(c);a&&e.push(a.pos)}if(e.length<3)continue;const n=[];for(let i=0;i<e.length;i++){const r=this.angle(o.pos,e[i]);n.push(r)}n.sort((i,r)=>i-r);let s=Math.PI*2;for(let i=0;i<n.length;i++){const r=(i+1)%n.length,c=n[r]-n[i];s=Math.min(s,c)}if(s<this.config.minIntersectionAngle*Math.PI/180){o.pos.x+=(this.rng()-.5)*5,o.pos.y+=(this.rng()-.5)*5,this.network.spatialIndex.clear();for(const[r,c]of this.network.nodes)this.network.spatialIndex.insert(r,c.pos.x,c.pos.y)}}}applyEraEvolution(){const t=parseInt(this.config.era.substring(0,4));for(const o of this.network.edges.values())o.material=C(this.config.era,o.roadClass),t<=1920?o.width=N[o.roadClass]*.8:t>=1960&&(o.width=N[o.roadClass]*1.1),t>=1950&&o.roadClass==="street"&&this.rng()<.2&&(o.roadClass="avenue",o.width=N.avenue)}clipToBounds(t){return{x:Math.max(0,Math.min(this.config.bounds.width,t.x)),y:Math.max(0,Math.min(this.config.bounds.height,t.y))}}distance(t,o){const e=o.x-t.x,n=o.y-t.y;return Math.sqrt(e*e+n*n)}angle(t,o){return Math.atan2(o.y-t.y,o.x-t.x)}angleDifference(t,o){let e=Math.abs(o-t);return e>Math.PI&&(e=2*Math.PI-e),e}paintRoad(t,o,e){const n=this.network.addNode(t.x,t.y),s=this.network.addNode(o.x,o.y),i=C(this.config.era,e);return this.network.addEdge(n,s,e,i)!==null}getNetwork(){return this.network}}class b{static polygonArea(t){let o=0;const e=t.length;for(let n=0;n<e;n++){const s=(n+1)%e;o+=t[n].x*t[s].y,o-=t[s].x*t[n].y}return Math.abs(o)/2}static polygonCentroid(t){let o=0,e=0;const n=this.polygonArea(t),s=t.length;for(let r=0;r<s;r++){const c=(r+1)%s,a=t[r].x*t[c].y-t[c].x*t[r].y;o+=(t[r].x+t[c].x)*a,e+=(t[r].y+t[c].y)*a}const i=1/(6*n);return{x:Math.abs(o*i),y:Math.abs(e*i)}}static pointToSegmentDistance(t,o,e){const n=e.x-o.x,s=e.y-o.y,i=n*n+s*s;if(i===0)return Math.sqrt((t.x-o.x)**2+(t.y-o.y)**2);let r=((t.x-o.x)*n+(t.y-o.y)*s)/i;r=Math.max(0,Math.min(1,r));const c=o.x+r*n,a=o.y+r*s;return Math.sqrt((t.x-c)**2+(t.y-a)**2)}static pointInPolygon(t,o){let e=!1;const n=o.length;for(let s=0,i=n-1;s<n;i=s++){const r=o[s].x,c=o[s].y,a=o[i].x,h=o[i].y;c>t.y!=h>t.y&&t.x<(a-r)*(t.y-c)/(h-c)+r&&(e=!e)}return e}static offsetPolygon(t,o){const e=t.length,n=[];for(let s=0;s<e;s++){const i=t[(s-1+e)%e],r=t[s],c=t[(s+1)%e],a=r.x-i.x,h=r.y-i.y,l=Math.sqrt(a*a+h*h),g=-h/l,d=a/l,u=c.x-r.x,y=c.y-r.y,f=Math.sqrt(u*u+y*y),p=-y/f,x=u/f;let m=(g+p)/2,I=(d+x)/2;const M=Math.sqrt(m*m+I*I);if(M>.001){m/=M,I/=M;const z=g*p+d*x,T=o/Math.sqrt((1+z)/2);n.push({x:r.x+m*T,y:r.y+I*T})}else n.push({...r})}return n}static polygonPerimeter(t){let o=0;const e=t.length;for(let n=0;n<e;n++){const s=(n+1)%e,i=t[s].x-t[n].x,r=t[s].y-t[n].y;o+=Math.sqrt(i*i+r*r)}return o}static lineIntersection(t,o,e,n){const s=(t.x-o.x)*(e.y-n.y)-(t.y-o.y)*(e.x-n.x);if(Math.abs(s)<1e-4)return null;const i=((t.x-e.x)*(e.y-n.y)-(t.y-e.y)*(e.x-n.x))/s,r=-((t.x-o.x)*(t.y-e.y)-(t.y-o.y)*(t.x-e.x))/s;return i>=0&&i<=1&&r>=0&&r<=1?{x:t.x+i*(o.x-t.x),y:t.y+i*(o.y-t.y)}:null}}class ct{constructor(t){k(this,"rng");this.rng=t}subdivideWithSkeleton(t,o,e,n){const s=[],i=_[o],r=e==="high"?.7:e==="medium"?.85:1,c=(i.min+i.max)/2*r,a=c*W[e],h=t[n],l=t[(n+1)%t.length],g=Math.sqrt((l.x-h.x)**2+(l.y-h.y)**2);Math.max(1,Math.floor(g/i.max)),Math.max(1,Math.ceil(g/i.min));const d=Math.max(1,Math.round(g/c)),u={x:(l.x-h.x)/g,y:(l.y-h.y)/g},y={x:-u.y,y:u.x},p=this.estimateBlockDepth(t,n)>a*2.5&&e!=="low";for(let x=0;x<d;x++){const m=x/d,I=(x+1)/d,M={x:h.x+m*(l.x-h.x),y:h.y+m*(l.y-h.y)},z={x:h.x+I*(l.x-h.x),y:h.y+I*(l.y-h.y)},T={x:z.x+y.x*a,y:z.y+y.y*a},A={x:M.x+y.x*a,y:M.y+y.y*a},B=this.clipToPolygon([M,z,T,A],t);if(B.length>=3&&b.polygonArea(B)>=50&&s.push(B),p){const L={x:A.x,y:A.y},K={x:T.x,y:T.y},J={x:T.x+y.x*a,y:T.y+y.y*a},Q={x:A.x+y.x*a,y:A.y+y.y*a},F=this.clipToPolygon([L,K,J,Q],t);F.length>=3&&b.polygonArea(F)>=50&&s.push(F)}}return s}subdivideWithVoronoi(t,o,e){const n=[],s=b.polygonArea(t),i=_[o],r=(i.min+i.max)/2,c=e==="high"?.6:e==="medium"?.8:1,a=r*r*W[e]*c;Math.max(2,Math.floor(s/(i.max*i.max*2)));const h=Math.ceil(s/(i.min*i.min*.8)),l=Math.max(2,Math.min(h,Math.round(s/a))),g=[],d=this.getPolygonBounds(t),u=Math.ceil(Math.sqrt(l)),y=(d.maxX-d.minX)/u,f=(d.maxY-d.minY)/u;for(let x=0;x<u&&g.length<l;x++)for(let m=0;m<u&&g.length<l;m++){const I=(this.rng()-.5)*y*.3,M=(this.rng()-.5)*f*.3,z=d.minX+(m+.5)*y+I,T=d.minY+(x+.5)*f+M,A={x:z,y:T};b.pointInPolygon(A,t)&&g.push(A)}let p=0;for(;g.length<l&&p<l*20;){const x=d.minX+this.rng()*(d.maxX-d.minX),m=d.minY+this.rng()*(d.maxY-d.minY),I={x,y:m};if(b.pointInPolygon(I,t)){let M=!1;const z=Math.sqrt(a)*.4;for(const T of g)if(Math.sqrt((T.x-x)**2+(T.y-m)**2)<z){M=!0;break}M||g.push(I)}p++}for(let x=0;x<g.length;x++){const m=this.computeVoronoiCell(g[x],g,t);m.length>=3&&b.polygonArea(m)>=50&&n.push(m)}return n}computeVoronoiCell(t,o,e){let n=[...e];for(const s of o){if(s===t)continue;const i={x:(t.x+s.x)/2,y:(t.y+s.y)/2},r=s.x-t.x,a=-(s.y-t.y),h=r;if(n=this.clipByHalfPlane(n,i,{x:a,y:h}),n.length<3)break}return n}clipByHalfPlane(t,o,e){if(t.length<3)return[];const n=[],s=t.length;for(let i=0;i<s;i++){const r=t[i],c=t[(i+1)%s],a=(r.x-o.x)*e.x+(r.y-o.y)*e.y,h=(c.x-o.x)*e.x+(c.y-o.y)*e.y;if(a>=0){if(n.push(r),h<0){const l=a/(a-h);n.push({x:r.x+l*(c.x-r.x),y:r.y+l*(c.y-r.y)})}}else if(h>=0){const l=a/(a-h);n.push({x:r.x+l*(c.x-r.x),y:r.y+l*(c.y-r.y)})}}return n}clipToPolygon(t,o){let e=t;for(let n=0;n<o.length&&e.length!==0;n++){const s=e;e=[];const i=o[n],r=o[(n+1)%o.length];for(let c=0;c<s.length;c++){const a=s[c],h=s[(c-1+s.length)%s.length],l=this.isLeftOfLine(a,i,r),g=this.isLeftOfLine(h,i,r);if(l){if(!g){const d=b.lineIntersection(h,a,i,r);d&&e.push(d)}e.push(a)}else if(g){const d=b.lineIntersection(h,a,i,r);d&&e.push(d)}}}return e}isLeftOfLine(t,o,e){return(e.x-o.x)*(t.y-o.y)-(e.y-o.y)*(t.x-o.x)>=0}getPolygonBounds(t){let o=1/0,e=1/0,n=-1/0,s=-1/0;for(const i of t)o=Math.min(o,i.x),e=Math.min(e,i.y),n=Math.max(n,i.x),s=Math.max(s,i.y);return{minX:o,minY:e,maxX:n,maxY:s}}estimateBlockDepth(t,o){const e=t[o],n=t[(o+1)%t.length];(e.x+n.x)/2,(e.y+n.y)/2;let s=0;for(const i of t){const r=b.pointToSegmentDistance(i,e,n);s=Math.max(s,r)}return s}}class X{constructor(t){k(this,"blocks");k(this,"parcels");k(this,"nextBlockId",0);k(this,"nextParcelId",0);k(this,"subdivider");this.blocks=new Map,this.parcels=new Map,this.subdivider=new ct(t)}findCityBlocks(t){this.blocks.clear();const o=t.edges,e=t.nodes,n=new Map;for(const[r,c]of o)n.has(c.nodeA)||n.set(c.nodeA,new Set),n.has(c.nodeB)||n.set(c.nodeB,new Set),n.get(c.nodeA).add(c.nodeB),n.get(c.nodeB).add(c.nodeA);const s=new Set,i=[];for(const[r,c]of n){if(s.has(r))continue;const a=[r],h=[],l=new Set;for(;a.length>0;){const g=a[a.length-1];if(l.has(g)){const d=h.indexOf(g);if(d!==-1){const u=h.slice(d);u.length>=3&&u.length<=12&&i.push([...u])}a.pop(),h[h.length-1]===g&&(h.pop(),l.delete(g))}else{s.add(g),h.push(g),l.add(g);const d=n.get(g)||new Set;let u=!1;for(const y of d)if(!s.has(y)||l.has(y)){a.push(y),u=!0;break}u||(a.pop(),h.pop(),l.delete(g))}if(i.length>500)break}}for(const r of i){const c=[],a=[];for(let h=0;h<r.length;h++){const l=r[h],g=e.get(l);g&&c.push({...g.pos});const d=r[(h+1)%r.length];for(const[u,y]of o)if(y.nodeA===l&&y.nodeB===d||y.nodeB===l&&y.nodeA===d){a.push(u);break}}if(c.length>=3){const h=b.polygonArea(c);if(h>100&&h<5e4){const l={id:this.nextBlockId++,vertices:c,holes:[],parcels:[],area:h,perimeter:b.polygonPerimeter(c),roadEdges:a};this.blocks.set(l.id,l)}}}}paintZone(t,o){const e=[];let n=!1;for(const[s,i]of this.blocks)if(this.polygonsIntersect(i.vertices,t.polygon)){n=!0;for(const l of i.parcels)this.parcels.delete(l);i.parcels=[];const r=t.subdivisionMethod||"skeleton";let c=0,a=1/0;for(let l=0;l<i.vertices.length;l++){const g=i.vertices[l],d=i.vertices[(l+1)%i.vertices.length],u={x:(g.x+d.x)/2,y:(g.y+d.y)/2},y=o.edges,f=o.nodes;for(const p of i.roadEdges){const x=y.get(p);if(x){const m=f.get(x.nodeA),I=f.get(x.nodeB);if(m&&I){const M=b.pointToSegmentDistance(u,m.pos,I.pos);M<a&&(a=M,c=l)}}}}let h;r==="voronoi"?h=this.subdivider.subdivideWithVoronoi(i.vertices,t.zoneType,t.zoneDensity):h=this.subdivider.subdivideWithSkeleton(i.vertices,t.zoneType,t.zoneDensity,c);for(const l of h){if(l.length<3)continue;const g=b.polygonArea(l);if(g<50)continue;let d=0,u=-1,y=!1;const f=new Set;for(let x=0;x<l.length;x++){const m=l[x],I=l[(x+1)%l.length],M=Math.sqrt((I.x-m.x)**2+(I.y-m.y)**2);for(let z=0;z<i.vertices.length;z++){const T=i.vertices[z],A=i.vertices[(z+1)%i.vertices.length];if(this.edgesOverlap(m,I,T,A))if(d+=M,i.roadEdges.length>0){const B=i.roadEdges[z];B!==void 0&&B>=0&&(f.add(B),u===-1&&(u=B))}else M>10&&(u===-1&&(u=z),f.add(z))}}if(y=f.size>1,d===0&&l.length>=3){let x=0;for(let m=0;m<l.length;m++){const I=l[m],M=l[(m+1)%l.length],z=Math.sqrt((M.x-I.x)**2+(M.y-I.y)**2);x=Math.max(x,z)}d=x}const p={id:this.nextParcelId++,vertices:l,zoneType:t.zoneType,zoneDensity:t.zoneDensity,area:g,frontage:d,frontageEdge:u,isCorner:y,centroid:b.polygonCentroid(l),blockId:s};this.parcels.set(p.id,p),i.parcels.push(p.id),e.push(p.id)}}if(!n&&t.polygon.length>=3){console.log("[ProcGen] No blocks found, creating standalone zone");const s={id:this.nextBlockId++,vertices:t.polygon,holes:[],parcels:[],area:b.polygonArea(t.polygon),perimeter:b.polygonPerimeter(t.polygon),roadEdges:[]};this.blocks.set(s.id,s);const i=this.subdivider.subdivideWithSkeleton(t.polygon,t.zoneType,t.zoneDensity,0);for(const r of i){if(r.length<3)continue;const c=b.polygonArea(r);if(c<50)continue;let a=0;if(r.length>=3)for(let l=0;l<r.length;l++){const g=r[l],d=r[(l+1)%r.length],u=Math.sqrt((d.x-g.x)**2+(d.y-g.y)**2);a=Math.max(a,u)}const h={id:this.nextParcelId++,vertices:r,zoneType:t.zoneType,zoneDensity:t.zoneDensity,area:c,frontage:a,frontageEdge:-1,isCorner:!1,centroid:b.polygonCentroid(r),blockId:s.id};this.parcels.set(h.id,h),s.parcels.push(h.id),e.push(h.id)}console.log("[ProcGen] Created",s.parcels.length,"parcels in standalone zone")}return e}polygonsIntersect(t,o){for(const e of t)if(b.pointInPolygon(e,o))return!0;for(const e of o)if(b.pointInPolygon(e,t))return!0;for(let e=0;e<t.length;e++){const n=t[e],s=t[(e+1)%t.length];for(let i=0;i<o.length;i++){const r=o[i],c=o[(i+1)%o.length];if(b.lineIntersection(n,s,r,c))return!0}}return!1}edgesOverlap(t,o,e,n){const i={x:o.x-t.x,y:o.y-t.y},r={x:n.x-e.x,y:n.y-e.y},c=Math.sqrt(i.x*i.x+i.y*i.y),a=Math.sqrt(r.x*r.x+r.y*r.y);if(c<.001||a<.001||(i.x/=c,i.y/=c,r.x/=a,r.y/=a,Math.abs(i.x*r.x+i.y*r.y)<.95))return!1;const l=b.pointToSegmentDistance(t,e,n),g=b.pointToSegmentDistance(o,e,n);return l<2&&g<2}calculatePerimeter(t){let o=0;for(let e=0;e<t.length;e++){const n=t[e],s=t[(e+1)%t.length];o+=Math.sqrt((s.x-n.x)**2+(s.y-n.y)**2)}return o}getParcelsTypedArrays(){const t=this.parcels.size,o=this.blocks.size;let e=0;for(const h of this.parcels.values())e+=h.vertices.length+1;const n=new Float32Array(t*9),s=new Float32Array(e*2),i=new Float32Array(o*4);let r=0,c=0;for(const h of this.parcels.values()){n[r*9]=h.id,n[r*9+1]=this.zoneTypeToInt(h.zoneType),n[r*9+2]=this.zoneDensityToInt(h.zoneDensity),n[r*9+3]=h.area,n[r*9+4]=h.frontage,n[r*9+5]=h.isCorner?1:0,n[r*9+6]=h.centroid.x,n[r*9+7]=h.centroid.y,n[r*9+8]=h.blockId;for(const l of h.vertices)s[c*2]=l.x,s[c*2+1]=l.y,c++;s[c*2]=-999999,s[c*2+1]=-999999,c++,r++}let a=0;for(const h of this.blocks.values())i[a*4]=h.id,i[a*4+1]=h.area,i[a*4+2]=h.perimeter,i[a*4+3]=h.parcels.length,a++;return{parcelData:n,parcelVertices:s,blockData:i}}zoneTypeToInt(t){return{residential:0,commercial:1,industrial:2,none:3}[t]}zoneDensityToInt(t){return{low:0,medium:1,high:2}[t]}clear(){this.blocks.clear(),this.parcels.clear(),this.nextBlockId=0,this.nextParcelId=0}getBlocks(){return Array.from(this.blocks.values())}getParcels(){return Array.from(this.parcels.values())}}const O=3,at={low:{min:4,max:6},medium:{min:2,max:4},high:{min:1,max:2}},j={low:{min:3,max:6},medium:{min:9,max:15},high:{min:18,max:60}},lt={"1890s":["victorian"],"1910s":["victorian","art-deco"],"1930s":["art-deco"],"1950s":["modern","brutalist"],"1970s":["brutalist","modern"],"1990s":["postmodern","contemporary"],"2010s":["contemporary","modern"],"2030s":["futuristic","contemporary"]},ht={"1890s":["gable","hip","mansard"],"1910s":["gable","hip","mansard","pyramid"],"1930s":["flat","pyramid","barrel"],"1950s":["flat","sawtooth"],"1970s":["flat"],"1990s":["flat","pyramid","hip"],"2010s":["flat","green"],"2030s":["flat","green","pyramid"]};class U{constructor(t){k(this,"rng");this.rng=t}splitVertical(t,o){let e,n;switch(o){case"victorian":e=.15,n=.2;break;case"art-deco":e=.2,n=.15;break;case"modern":case"contemporary":e=.1,n=.05;break;case"brutalist":e=.08,n=.03;break;case"postmodern":e=.12,n=.1;break;case"futuristic":e=.05,n=.08;break;default:e=.1,n=.1}e+=(this.rng()-.5)*.05,n+=(this.rng()-.5)*.05;const s=t*Math.max(.05,Math.min(.25,e)),i=t*Math.max(.03,Math.min(.25,n)),r=t-s-i;return{base:s,body:r,roof:i}}splitFloors(t){const o=Math.max(1,Math.round(t/O)),e=t/o,n=[];for(let s=0;s<o;s++)n.push(e);return n}subdivideFacade(t,o,e){const n=[],s=[];let i,r;switch(e){case"victorian":i=2,r=2;break;case"art-deco":i=2.5,r=2.5;break;case"modern":case"contemporary":i=2.8,r=3;break;case"brutalist":i=2.5,r=4;break;case"postmodern":i=2.4,r=2.8;break;case"futuristic":i=3,r=5;break;default:i=2,r=2.5}const c=Math.max(1,Math.floor(t/r)),a=Math.max(1,Math.floor(o/(i+1))),h=t/c,l=o/a;for(let g=0;g<a;g++)for(let d=0;d<c;d++)n.push({x:(d+.5)*h,y:(g+.5)*l});return{windows:n,details:s}}}class dt{constructor(t){k(this,"splitGrammar");k(this,"rng");this.rng=t,this.splitGrammar=new U(t)}addWindowsToFacade(t,o,e,n,s,i,r,c){if(c===2)return;const a=Math.sqrt((n.x-e.x)**2+(n.y-e.y)**2),h=i-s;let l=3,g=3.5;switch(r){case"modern":case"contemporary":l=3;break;case"brutalist":l=4;break;case"art-deco":g=4;break}const d=Math.floor(a/l),u=Math.floor(h/g);if(d<=0||u<=0)return;const y=.15;t.length;for(let f=0;f<u;f++)for(let p=0;p<d;p++){const x=(p+.5)/d,m=s+(f+.5)*g,I=e.x+(n.x-e.x)*x,M=e.y+(n.y-e.y)*x;t.push({x:I-y,y:M-y,z:m})}}addBalcony(t,o,e,n,s=3,i=1.5){const r=t.length;t.push({x:e.x-s/2,y:e.y,z:n}),t.push({x:e.x+s/2,y:e.y,z:n}),t.push({x:e.x+s/2,y:e.y+i,z:n}),t.push({x:e.x-s/2,y:e.y+i,z:n});const c=1.1;return t.push({x:e.x-s/2,y:e.y+i,z:n+c}),t.push({x:e.x+s/2,y:e.y+i,z:n+c}),o.push([r,r+1,r+2,r+3]),o.push([r+2,r+3,r+4,r+5]),r+6}generateMesh(t,o){const e=[];return t.baseHeight>0&&e.push(this.generateBase(t,o)),t.bodyHeight>0&&e.push(this.generateBody(t,o)),t.roofHeight>0&&e.push(this.generateRoof(t,o)),this.combineComponents(e,o)}generateBase(t,o){const e=[],n=[],i=t.baseHeight,r=t.zoneType||"residential",c=t.zoneDensity||"medium";let a=t.footprint,h=!1;if(r==="commercial"&&(h=c!=="low"&&this.rng()>.4,t.style==="art-deco"||t.style,c==="high"&&t.floorCount>10),r==="residential"&&(h=c==="high"&&this.rng()>.5,c==="high"&&t.floorCount>15),h&&a.length>=4){const p=Math.min(8,this.getFootprintBounds(a).maxX-this.getFootprintBounds(a).minX*.4);for(const x of a)e.push({x:x.x,y:x.y,z:0});if([...a],a.length>=4){const x=a[0],m=a[1],I=Math.sqrt((m.x-x.x)**2+(m.y-x.y)**2);if(I>p){const M=p/I*.3,z=p/I*.7,T={x:x.x+(m.x-x.x)*M,y:x.y+(m.y-x.y)*M},A={x:x.x+(m.x-x.x)*z,y:x.y+(m.y-x.y)*z};e.push({x:T.x,y:T.y-2,z:0}),e.push({x:A.x,y:A.y-2,z:0})}}for(const x of a)e.push({x:x.x,y:x.y,z:i})}else{for(const f of a)e.push({x:f.x,y:f.y,z:0});for(const f of a)e.push({x:f.x,y:f.y,z:i})}const l=a.length;for(let f=0;f<l;f++){const p=(f+1)%l,x=h?l+2:l;n.push([f,p,p+x,f+x])}const g=[],d=[],u=h?l+2:l;for(let f=0;f<l;f++)g.push(f+u),d.unshift(f);n.push(g),n.push(d);let y=0;return r==="commercial"?y=t.style==="modern"||t.style==="contemporary"?8:1:r==="industrial"?y=9:y=t.style==="modern"?1:0,{type:"base",vertices:e,faces:n,materialId:y}}generateBody(t,o){const e=t.baseHeight,n=t.baseHeight+t.bodyHeight,s=t.zoneType||"residential";switch(t.zoneDensity,s){case"residential":return this.generateResidentialBody(t,e,n,o);case"commercial":return this.generateCommercialBody(t,e,n,o);case"industrial":return this.generateIndustrialBody(t,e,n,o);default:return this.generateGenericBody(t,e,n,o)}}generateResidentialBody(t,o,e,n){const s=[],i=[],r=[],c=t.zoneDensity||"medium";let a=[...t.footprint];const h=this.splitGrammar.splitFloors(t.bodyHeight);let l=o;const g=c!=="low"&&t.style!=="victorian"&&this.rng()>.3,d=t.floorCount>8&&this.rng()>.4,u=1.5;if(n===2)return this.generateGenericBody(t,o,e,n);for(let p=0;p<=h.length;p++){d&&p>0&&(p===Math.floor(h.length*.7)?a=b.offsetPolygon(a,-1):p===Math.floor(h.length*.85)&&(a=b.offsetPolygon(a,-.5)));for(const x of a)s.push({x:x.x,y:x.y,z:l});if(g&&p>0&&p%2===0&&p<h.length){const x=b.offsetPolygon(a,u);for(const m of x)r.push({x:m.x,y:m.y,z:l})}p<h.length&&(l+=h[p])}const y=h.length+1,f=t.footprint.length;for(let p=0;p<y-1;p++)for(let x=0;x<f;x++){const m=(x+1)%f,I=p*f+x,M=p*f+m,z=(p+1)*f+x,T=(p+1)*f+m;i.push([I,M,T,z])}return s.length,s.push(...r),{type:"body",vertices:s,faces:i,materialId:c==="low"?7:2}}generateCommercialBody(t,o,e,n){const s=[],i=[],r=t.zoneDensity||"medium";let c=[...t.footprint];const a=this.splitGrammar.splitFloors(t.bodyHeight),h=a[0]*1.5,l=(t.bodyHeight-h)/(a.length-1);let g=o;const d=t.style==="modern"||t.style==="contemporary"||t.style==="futuristic";if(r!=="low"&&this.rng()>.4,r==="high"&&this.rng()>.5,n===2)return this.generateGenericBody(t,o,e,n);for(let f=0;f<=a.length;f++){f===1&&t.style==="art-deco"&&(c=b.offsetPolygon(c,-.3)),r==="high"&&t.floorCount>15&&(f===Math.floor(a.length*.6)?c=b.offsetPolygon(c,-1.5):f===Math.floor(a.length*.8)&&(c=b.offsetPolygon(c,-1)));for(const p of c)s.push({x:p.x,y:p.y,z:g});f===0?g+=h:f<a.length&&(g+=l)}const u=a.length+1,y=c.length;for(let f=0;f<u-1;f++)for(let p=0;p<y;p++){const x=(p+1)%y,m=f*y+p,I=f*y+x,M=(f+1)*y+p,z=(f+1)*y+x;i.push([m,I,z,M])}return{type:"body",vertices:s,faces:i,materialId:d?8:2}}generateIndustrialBody(t,o,e,n){const s=[],i=[],r=t.zoneDensity||"medium",c=t.footprint,a=this.rng()>.3,h=r!=="low"&&this.rng()>.4;if(r==="high"&&this.rng()>.5,n===2)return this.generateGenericBody(t,o,e,n);const l=t.bodyHeight*(h?.8:1);for(const d of c)s.push({x:d.x,y:d.y,z:o});for(const d of c)s.push({x:d.x,y:d.y,z:o+l});if(h){const d=b.offsetPolygon(c,-2),u=o+l,y=e;for(const f of d)s.push({x:f.x,y:f.y,z:u});for(const f of d)s.push({x:f.x,y:f.y,z:y})}const g=c.length;for(let d=0;d<g;d++){const u=(d+1)%g;i.push([d,u,u+g,d+g])}if(h){const d=g*2;for(let u=0;u<g;u++){const y=(u+1)%g;i.push([d+u,d+y,d+y+g,d+u+g])}}if(a&&c.length>=4){const f=c[0];c[1];const p=s.length;s.push({x:f.x,y:f.y-3,z:o}),s.push({x:f.x+4,y:f.y-3,z:o}),s.push({x:f.x+4,y:f.y,z:o}),s.push({x:f.x,y:f.y,z:o}),s.push({x:f.x,y:f.y-3,z:o+1.5}),s.push({x:f.x+4,y:f.y-3,z:o+1.5}),s.push({x:f.x+4,y:f.y,z:o+1.5}),s.push({x:f.x,y:f.y,z:o+1.5}),i.push([p,p+1,p+5,p+4]),i.push([p+1,p+2,p+6,p+5]),i.push([p+2,p+3,p+7,p+6]),i.push([p+3,p,p+4,p+7]),i.push([p+4,p+5,p+6,p+7])}return{type:"body",vertices:s,faces:i,materialId:9}}generateGenericBody(t,o,e,n){const s=[],i=[];let r=[...t.footprint];const c=this.splitGrammar.splitFloors(t.bodyHeight);let a=o;if(n===2){for(const u of r)s.push({x:u.x,y:u.y,z:o});for(const u of r)s.push({x:u.x,y:u.y,z:e});const d=r.length;for(let u=0;u<d;u++){const y=(u+1)%d;i.push([u,y,y+d,u+d])}}else{for(let y=0;y<=c.length;y++){t.floorCount>10&&y>0&&y%5===0&&(r=b.offsetPolygon(r,-.5));for(const f of r)s.push({x:f.x,y:f.y,z:a});y<c.length&&(a+=c[y])}const d=c.length+1,u=r.length;for(let y=0;y<d-1;y++)for(let f=0;f<u;f++){const p=(f+1)%u,x=y*u+f,m=y*u+p,I=(y+1)*u+f,M=(y+1)*u+p;i.push([x,m,M,I])}}const h=r.length,l=[],g=[];for(let d=0;d<h;d++)l.push(d),g.push(s.length-h+d);return i.push(l.reverse()),i.push(g),{type:"body",vertices:s,faces:i,materialId:2}}generateRoof(t,o){const e=t.baseHeight+t.bodyHeight,n=t.height,s=t.zoneType||"residential",i=t.zoneDensity||"medium";let r=t.roofType;switch(s==="industrial"&&r!=="sawtooth"&&r!=="flat"&&this.rng()>.7&&(r="sawtooth"),s==="commercial"&&i==="high"&&r!=="flat"&&this.rng()>.8&&(r="flat"),r){case"flat":return this.generateEnhancedFlatRoof(t,e,n,o);case"gable":return this.generateGableRoof(t,e,n,o);case"hip":return this.generateHipRoof(t,e,n,o);case"mansard":return this.generateMansardRoof(t,e,n,o);case"pyramid":return this.generatePyramidRoof(t,e,n,o);case"barrel":return this.generateBarrelRoof(t,e,n,o);case"sawtooth":return this.generateSawtoothRoof(t,e,n,o);case"green":return this.generateGreenRoof(t,e,n,o);default:return this.generateEnhancedFlatRoof(t,e,n,o)}}generateEnhancedFlatRoof(t,o,e,n){const s=[],i=[],r=t.zoneType||"residential",c=t.zoneDensity||"medium",a=t.footprint,h=r==="industrial"?.5:.3,l=b.offsetPolygon(a,-h),g=(r==="commercial"||r==="industrial")&&c!=="low"&&this.rng()>.3;r==="commercial"&&c==="high"&&t.floorCount>20&&this.rng()>.7;for(const f of a)s.push({x:f.x,y:f.y,z:o});for(const f of l)s.push({x:f.x,y:f.y,z:o});for(const f of a)s.push({x:f.x,y:f.y,z:e});const d=e-.1;for(const f of l)s.push({x:f.x,y:f.y,z:d});const u=a.length;for(let f=0;f<u;f++){const p=(f+1)%u;i.push([f,p,p+2*u,f+2*u]),i.push([f+u,f+3*u,p+3*u,p+u]),i.push([f+2*u,p+2*u,p+3*u,f+3*u])}const y=[];for(let f=0;f<u;f++)y.push(f+3*u);if(i.push(y),g&&n<2){const f=this.getFootprintBounds(l),p=(f.minX+f.maxX)/2,x=(f.minY+f.maxY)/2,m=3,I=2.5,M=s.length;s.push({x:p-m,y:x-m,z:d}),s.push({x:p+m,y:x-m,z:d}),s.push({x:p+m,y:x+m,z:d}),s.push({x:p-m,y:x+m,z:d}),s.push({x:p-m,y:x-m,z:d+I}),s.push({x:p+m,y:x-m,z:d+I}),s.push({x:p+m,y:x+m,z:d+I}),s.push({x:p-m,y:x+m,z:d+I}),i.push([M,M+1,M+5,M+4]),i.push([M+1,M+2,M+6,M+5]),i.push([M+2,M+3,M+7,M+6]),i.push([M+3,M,M+4,M+7]),i.push([M+4,M+5,M+6,M+7])}return{type:"roof",vertices:s,faces:i,materialId:r==="industrial"?5:3}}generateFlatRoof(t,o,e,n){const s=[],i=[],r=t.footprint,c=b.offsetPolygon(r,-.3);for(const l of r)s.push({x:l.x,y:l.y,z:o});for(const l of c)s.push({x:l.x,y:l.y,z:o});for(const l of r)s.push({x:l.x,y:l.y,z:e});for(const l of c)s.push({x:l.x,y:l.y,z:e-.1});const a=r.length;for(let l=0;l<a;l++){const g=(l+1)%a;i.push([l,g,g+2*a,l+2*a]),i.push([l+a,l+3*a,g+3*a,g+a]),i.push([l+2*a,g+2*a,g+3*a,l+3*a])}const h=[];for(let l=0;l<a;l++)h.push(l+3*a);return i.push(h),{type:"roof",vertices:s,faces:i,materialId:3}}generateGableRoof(t,o,e,n){const s=[],i=[],r=t.footprint,c=this.getFootprintBounds(r);(c.minX+c.maxX)/2;const a=(c.minY+c.maxY)/2;for(const d of r)s.push({x:d.x,y:d.y,z:o});s.push({x:c.minX,y:a,z:e}),s.push({x:c.maxX,y:a,z:e});const h=r.length,l=h,g=h+1;return i.push([0,1,l]),i.push([2,3,g]),i.push([0,l,g,3]),i.push([1,2,g,l]),{type:"roof",vertices:s,faces:i,materialId:4}}generateHipRoof(t,o,e,n){return this.generatePyramidRoof(t,o,e,n)}generateMansardRoof(t,o,e,n){const s=[],i=[],r=t.footprint,c=b.offsetPolygon(r,-1),a=b.offsetPolygon(r,-1.5),h=o+(e-o)*.7;for(const d of r)s.push({x:d.x,y:d.y,z:o});for(const d of c)s.push({x:d.x,y:d.y,z:h});for(const d of a)s.push({x:d.x,y:d.y,z:e});const l=r.length;for(let d=0;d<l;d++){const u=(d+1)%l;i.push([d,u,u+l,d+l])}for(let d=0;d<l;d++){const u=(d+1)%l;i.push([d+l,u+l,u+2*l,d+2*l])}const g=[];for(let d=0;d<l;d++)g.push(d+2*l);return i.push(g),{type:"roof",vertices:s,faces:i,materialId:4}}generatePyramidRoof(t,o,e,n){const s=[],i=[],r=t.footprint,c=b.polygonCentroid(r);for(const g of r)s.push({x:g.x,y:g.y,z:o});s.push({x:c.x,y:c.y,z:e});const a=r.length,h=a;for(let g=0;g<a;g++){const d=(g+1)%a;i.push([g,d,h])}const l=[];for(let g=a-1;g>=0;g--)l.push(g);return i.push(l),{type:"roof",vertices:s,faces:i,materialId:4}}generateBarrelRoof(t,o,e,n){const s=[],i=[],r=t.footprint,c=this.getFootprintBounds(r),a=(c.minY+c.maxY)/2,h=(c.maxY-c.minY)/2,l=n===2?3:5;for(let d=0;d<=l;d++){const u=d/l*Math.PI,y=-h*Math.cos(u),f=h*Math.sin(u);for(const p of r)s.push({x:p.x,y:a+y,z:o+f})}const g=r.length;for(let d=0;d<l;d++)for(let u=0;u<g;u++){const y=(u+1)%g,f=d*g+u,p=d*g+y,x=(d+1)*g+u,m=(d+1)*g+y;i.push([f,p,m,x])}return{type:"roof",vertices:s,faces:i,materialId:4}}generateSawtoothRoof(t,o,e,n){const s=[],i=[],r=t.footprint,c=this.getFootprintBounds(r),a=c.maxX-c.minX,h=Math.max(2,Math.floor(a/8)),l=a/h;for(let g=0;g<h;g++){const d=c.minX+g*l,u=d+l*.7,y=d+l;s.push({x:d,y:c.minY,z:o}),s.push({x:d,y:c.maxY,z:o}),s.push({x:u,y:c.minY,z:e}),s.push({x:u,y:c.maxY,z:e}),s.push({x:y,y:c.minY,z:o}),s.push({x:y,y:c.maxY,z:o});const f=g*6;i.push([f,f+1,f+3,f+2]),i.push([f+2,f+3,f+5,f+4]),i.push([f,f+2,f+4]),i.push([f+1,f+5,f+3])}return{type:"roof",vertices:s,faces:i,materialId:5}}generateGreenRoof(t,o,e,n){const s=this.generateEnhancedFlatRoof(t,o,e,n);return s.materialId=6,s}getFootprintBounds(t){let o=1/0,e=-1/0,n=1/0,s=-1/0;for(const i of t)o=Math.min(o,i.x),e=Math.max(e,i.x),n=Math.min(n,i.y),s=Math.max(s,i.y);return{minX:o,maxX:e,minY:n,maxY:s}}combineComponents(t,o){let e=0,n=0;for(const d of t)e+=d.vertices.length,n+=d.faces.reduce((u,y)=>u+(y.length-2),0);const s=new Float32Array(e*3),i=new Float32Array(e*3),r=new Float32Array(e*2),c=new Uint32Array(n*3),a=new Uint8Array(n);let h=0,l=0,g=0;for(const d of t){for(let u=0;u<d.vertices.length;u++){const y=d.vertices[u];s[h*3]=y.x,s[h*3+1]=y.y,s[h*3+2]=y.z,r[h*2]=y.x/10,r[h*2+1]=y.y/10,h++}for(const u of d.faces)if(u.length===3)c[l++]=u[0]+h-d.vertices.length,c[l++]=u[1]+h-d.vertices.length,c[l++]=u[2]+h-d.vertices.length,a[g++]=d.materialId;else if(u.length===4)c[l++]=u[0]+h-d.vertices.length,c[l++]=u[1]+h-d.vertices.length,c[l++]=u[2]+h-d.vertices.length,a[g++]=d.materialId,c[l++]=u[0]+h-d.vertices.length,c[l++]=u[2]+h-d.vertices.length,c[l++]=u[3]+h-d.vertices.length,a[g++]=d.materialId;else{const y=u[0]+h-d.vertices.length;for(let f=1;f<u.length-1;f++)c[l++]=y,c[l++]=u[f]+h-d.vertices.length,c[l++]=u[f+1]+h-d.vertices.length,a[g++]=d.materialId}}return this.calculateNormals(s,c,i),{positions:s,normals:i,uvs:r,indices:c,materialIds:a,lod:o}}calculateNormals(t,o,e){e.fill(0);for(let n=0;n<o.length;n+=3){const s=o[n]*3,i=o[n+1]*3,r=o[n+2]*3,c=t[s],a=t[s+1],h=t[s+2],l=t[i],g=t[i+1],d=t[i+2],u=t[r],y=t[r+1],f=t[r+2],p=l-c,x=g-a,m=d-h,I=u-c,M=y-a,z=f-h,T=x*z-m*M,A=m*I-p*z,B=p*M-x*I;e[s]+=T,e[s+1]+=A,e[s+2]+=B,e[i]+=T,e[i+1]+=A,e[i+2]+=B,e[r]+=T,e[r+1]+=A,e[r+2]+=B}for(let n=0;n<e.length;n+=3){const s=e[n],i=e[n+1],r=e[n+2],c=Math.sqrt(s*s+i*i+r*r);c>0&&(e[n]/=c,e[n+1]/=c,e[n+2]/=c)}}}class ${constructor(t){k(this,"buildings");k(this,"meshCache");k(this,"meshGenerator");k(this,"splitGrammar");k(this,"nextBuildingId",0);k(this,"rng");this.buildings=new Map,this.meshCache=new Map,this.rng=t,this.meshGenerator=new dt(t),this.splitGrammar=new U(t)}generateBuildingForParcel(t,o,e=1){if(t.zoneType==="none")return null;const n=H(t.id+e*1e3),s=this.getStyleForEra(o,n),i=this.getRoofForEra(o,t.zoneDensity,n),r=this.getSetback(t.zoneDensity,n),c=b.offsetPolygon(t.vertices,-r);if(c.length<3)return null;const a=j[t.zoneDensity],l=(a.min+n()*(a.max-a.min))*(1+(e-1)*.3),g=Math.max(1,Math.round(l/O));let d=l,u=s;switch(t.zoneType){case"commercial":d*=1.1;break;case"industrial":d*=.7,u=o>="1950s"?"modern":s;break}const y=this.splitGrammar.splitVertical(d,u),f={id:this.nextBuildingId++,parcelId:t.id,footprint:c,height:d,baseHeight:y.base,bodyHeight:y.body,roofHeight:y.roof,floorCount:g,style:u,roofType:i,setback:r,seed:t.id,zoneType:t.zoneType,zoneDensity:t.zoneDensity,level:e};return this.buildings.set(f.id,f),f}getBuildingMeshForParcel(t,o){let e=null;for(const[i,r]of this.buildings)if(r.parcelId===t){e=r;break}if(!e)return null;const n=`${e.id}_${o}`;let s=this.meshCache.get(n);return s||(s=this.meshGenerator.generateMesh(e,o),this.meshCache.set(n,s)),{buildingId:e.id,lod:o,positions:s.positions,indices:s.indices,normals:s.normals,uvs:s.uvs,materialIds:s.materialIds}}generateBuildings(t,o){const e=[];for(const n of t){if(n.zoneType==="none")continue;const s=H(n.id),i=this.getStyleForEra(o,s),r=this.getRoofForEra(o,n.zoneDensity,s),c=this.getSetback(n.zoneDensity,s),a=b.offsetPolygon(n.vertices,-c);if(a.length<3)continue;const h=j[n.zoneDensity],l=h.min+s()*(h.max-h.min),g=Math.max(1,Math.round(l/O));let d=l,u=i;switch(n.zoneType){case"commercial":d*=1.1;break;case"industrial":d*=.7,u=o>="1950s"?"modern":i;break}const y=this.splitGrammar.splitVertical(d,u),f={id:this.nextBuildingId++,parcelId:n.id,footprint:a,height:d,baseHeight:y.base,bodyHeight:y.body,roofHeight:y.roof,style:u,roofType:r,floorCount:g,setback:c,seed:n.id,zoneType:n.zoneType,zoneDensity:n.zoneDensity,level:1};this.buildings.set(f.id,f),e.push(f)}return e}getStyleForEra(t,o){const e=lt[t]||["modern"];return e[Math.floor(o()*e.length)]}getRoofForEra(t,o,e){const n=ht[t]||["flat"];return o==="high"&&e()>.3?"flat":n[Math.floor(e()*n.length)]}getSetback(t,o){const e=at[t];return e.min+o()*(e.max-e.min)}getBuildingMesh(t,o){const e=this.buildings.get(t);if(!e)return null;const n=`${t}_${o}`;if(this.meshCache.has(n))return this.meshCache.get(n);const s=this.meshGenerator.generateMesh(e,o);return this.meshCache.set(n,s),s}getAllBuildingMeshes(t){const o=[],e=[];for(const l of this.buildings.values()){const g=this.getBuildingMesh(l.id,t);g&&(o.push(g),e.push(l.id,l.parcelId,l.height,this.styleToInt(l.style),this.roofToInt(l.roofType)))}let n=0,s=0;for(const l of o)n+=l.positions.length,s+=l.indices.length;const i=new Float32Array(n+s),r=new Uint32Array(o.length*2),c=new Float32Array(e);let a=0,h=n;for(let l=0;l<o.length;l++){const g=o[l];r[l*2]=a,r[l*2+1]=h-n,i.set(g.positions,a),a+=g.positions.length;for(let d=0;d<g.indices.length;d++)i[h+d]=g.indices[d];h+=g.indices.length}return{meshData:i,buildingOffsets:r,buildingInfo:c}}styleToInt(t){return{victorian:0,"art-deco":1,modern:2,brutalist:3,postmodern:4,contemporary:5,futuristic:6}[t]}roofToInt(t){return{flat:0,gable:1,hip:2,mansard:3,pyramid:4,barrel:5,sawtooth:6,green:7}[t]}clear(){this.buildings.clear(),this.meshCache.clear(),this.nextBuildingId=0}getBuildings(){return Array.from(this.buildings.values())}}let E=H(1),V=1,D="1890s",q=null,v=null,w=null,S=null,R=null;function G(P,t="1890s"){console.log("[ProcGen] Initializing with seed:",P,"era:",t),V=P,D=t,E=H(P);const o={seed:P,era:t,bounds:{width:2e3,height:2e3},gridBias:t.startsWith("18")||t.startsWith("191")?.3:.6,density:t.startsWith("20")?.7:.5,blockSizeMin:t==="1890s"||t==="1910s"?60:80,blockSizeMax:t==="1890s"||t==="1910s"?120:150,minIntersectionAngle:30,centerCount:t==="1890s"?1:t.startsWith("20")?3:2};if(q=new rt(o,E),v=q.generate(),w=new X(E),S||(S=new $(E)),console.log("[ProcGen] Network generated:",v?"yes":"no"),console.log("[ProcGen] BlockManager initialized:",!!w),v){const e=v.nodes?v.nodes.size:0,n=v.edges?v.edges.size:0;console.log("[ProcGen] Network has",e,"nodes and",n,"edges")}R=new et,w=new X(E),v&&w.findCityBlocks(v),S=new $(E)}self.onmessage=P=>{var o;const t=P.data;switch(console.log("[ProcGen] Received message:",t.type),t.type){case"boot":if(G(t.seed||1,t.era||"1890s"),v){const e=v.getTypedArrays(),n=w?w.getBlocks().map(s=>({id:s.id,vertices:s.vertices,area:s.area,parcelCount:s.parcels.length})):[];self.postMessage({type:"roads-generated",data:e,segments:v.getRoadSegments(),blocks:n})}break;case"shuffle-seed":if(G(t.seed,D),v){const e=v.getTypedArrays(),n=w?w.getBlocks().map(s=>({id:s.id,vertices:s.vertices,area:s.area,parcelCount:s.parcels.length})):[];self.postMessage({type:"roads-generated",data:e,segments:v.getRoadSegments(),blocks:n})}break;case"set-era":if(D=t.era,G(V,t.era),v){const e=v.getTypedArrays(),n=w?w.getBlocks().map(s=>({id:s.id,vertices:s.vertices,area:s.area,parcelCount:s.parcels.length})):[];self.postMessage({type:"roads-generated",data:e,segments:v.getRoadSegments(),blocks:n})}break;case"paint-road":if(console.log("[ProcGen] Paint road request:",t),R){const{start:e,end:n,roadClass:s="street"}=t;console.log("[ProcGen] Painting road from",e,"to",n,"class:",s);const r={highway:24,avenue:16,street:12,local:8}[s]||12,c=s==="highway"?0:s==="avenue"?1:s==="street"?2:3;R.addSegment(e,n,r,c);const a=R.getSegments(),h=R.getIntersections();console.log("[ProcGen] After paint: ",a.length,"segments,",h.length,"intersections");const l=a.map(g=>({start:g.start,end:g.end,width:g.width,class:g.class,material:2}));self.postMessage({type:"road-painted",success:!0,segments:l,intersections:h.map(g=>({x:g.position.x,y:g.position.y,type:g.type,radius:g.radius}))})}else console.log("[ProcGen] No intersection handler available"),self.postMessage({type:"road-painted",success:!1,error:"Intersection handler not initialized"});break;case"get-roads":if(R){const e=R.getSegments(),n=R.getIntersections();console.log("[ProcGen] Sending roads data, segments:",e.length,"intersections:",n.length);const s=e.map(i=>({start:i.start,end:i.end,width:i.width,class:i.class,material:2}));self.postMessage({type:"roads-generated",segments:s,intersections:n.map(i=>({x:i.position.x,y:i.position.y,type:i.type,radius:i.radius}))})}else console.log("[ProcGen] No intersection handler available yet"),self.postMessage({type:"roads-generated",segments:[]});break;case"get-stats":if(v){const e=v.nodes.size,n=v.edges.size,i=v.getRoadSegments().reduce((a,h)=>{const l=h.end.x-h.start.x,g=h.end.y-h.start.y;return a+Math.sqrt(l*l+g*g)},0);let r=0,c=0;w&&(r=w.getBlocks().length,c=w.getParcels().length),self.postMessage({type:"network-stats",stats:{nodeCount:e,edgeCount:n,totalRoadLength:i,averageBlockSize:i>0?2e3*2e3/n:0,blockCount:r,parcelCount:c}})}break;case"paint-zone":if(console.log("[ProcGen] Paint zone request received:",t.zoneType,"Polygon:",t.polygon),console.log("[ProcGen] BlockManager exists:",!!w,"Network exists:",!!v),w&&v){const e={polygon:t.polygon||[],zoneType:t.zoneType||"residential",zoneDensity:t.zoneDensity||"medium",subdivisionMethod:t.subdivisionMethod||"skeleton"};console.log("[ProcGen] Paint request constructed:",e),console.log("[ProcGen] Blocks before painting:",w.getBlocks().length);const n=w.paintZone(e,v);console.log("[ProcGen] Affected parcels:",n.length);const s=w.getParcelsTypedArrays();console.log("[ProcGen] Parcel arrays size:",((o=s==null?void 0:s.parcelData)==null?void 0:o.length)||0);const r=w.getParcels().filter(c=>n.includes(c.id));self.postMessage({type:"zone-painted",affectedParcelIds:n,affectedParcels:r.map(c=>({id:c.id,zoneType:c.zoneType,zoneDensity:c.zoneDensity,area:c.area,frontage:c.frontage,centroid:c.centroid,vertices:c.vertices})),parcels:s,blocks:w.getBlocks().map(c=>({id:c.id,vertices:c.vertices,area:c.area,parcelCount:c.parcels.length}))})}else console.error("[ProcGen] Block manager not initialized!","blockManager:",!!w,"network:",!!v),self.postMessage({type:"zone-painted",error:"Block manager not initialized",affectedParcels:[]});break;case"get-parcels":if(w){const e=w.getParcelsTypedArrays(),n=w.getParcels();self.postMessage({type:"parcels-data",parcels:e,parcelList:n.map(s=>({id:s.id,vertices:s.vertices,zoneType:s.zoneType,zoneDensity:s.zoneDensity,area:s.area,frontage:s.frontage,isCorner:s.isCorner,centroid:s.centroid})),blocks:w.getBlocks().map(s=>({id:s.id,vertices:s.vertices,area:s.area,parcelCount:s.parcels.length}))})}else self.postMessage({type:"parcels-data",error:"Block manager not initialized",parcels:null});break;case"get-blocks":if(w){const e=w.getBlocks();self.postMessage({type:"blocks-data",blocks:e.map(n=>({id:n.id,vertices:n.vertices,holes:n.holes,area:n.area,perimeter:n.perimeter,parcelCount:n.parcels.length,roadEdges:n.roadEdges}))})}else self.postMessage({type:"blocks-data",error:"Block manager not initialized",blocks:[]});break;case"clear-zones":w&&(w.clear(),v&&w.findCityBlocks(v),S&&S.clear(),self.postMessage({type:"zones-cleared",success:!0}));break;case"generate-building-for-zone":if(w&&S){const{zoneId:e,zoneType:n,position:s,level:i,event:r}=t;console.log("[ProcGen] Generating building for zone",e,"event:",r,"level:",i);let a=w.getParcels().find(h=>{const l=b.polygonCentroid(h.vertices);return Math.sqrt((l.x-s.x)**2+(l.y-s.y)**2)<50});if(a){const h=S.generateBuildingForParcel(a,D,i),l=1,g=S.getBuildingMeshForParcel(a.id,l);self.postMessage({type:"building-spawned",zoneId:e,parcelId:a.id,building:h?{id:h.id,parcelId:h.parcelId,height:h.height,floorCount:h.floorCount,style:h.style,roofType:h.roofType}:null,meshData:g,lod:l})}else console.log("[ProcGen] No parcel found at position",s)}break;case"generate-buildings":if(w&&S){const e=w.getParcels(),n=S.generateBuildings(e,D),s=t.lod!==void 0?t.lod:1,i=S.getAllBuildingMeshes(s);self.postMessage({type:"buildings-generated",buildings:n.map(r=>({id:r.id,parcelId:r.parcelId,height:r.height,floorCount:r.floorCount,style:r.style,roofType:r.roofType})),meshData:i,lod:s})}else self.postMessage({type:"buildings-generated",error:"Managers not initialized",buildings:[]});break;case"get-buildings":if(S){const e=S.getBuildings(),n=t.lod!==void 0?t.lod:1,s=S.getAllBuildingMeshes(n);self.postMessage({type:"buildings-data",buildings:e.map(i=>({id:i.id,parcelId:i.parcelId,height:i.height,floorCount:i.floorCount,style:i.style,roofType:i.roofType})),meshData:s,lod:n})}else self.postMessage({type:"buildings-data",error:"Building manager not initialized",buildings:[]});break;case"get-building-mesh":if(S){const{buildingId:e,lod:n=1}=t,s=S.getBuildingMesh(e,n);s?self.postMessage({type:"building-mesh",buildingId:e,mesh:s,lod:n}):self.postMessage({type:"building-mesh",error:"Building not found",buildingId:e})}break;case"set-building-lod":if(S){const e=t.lod,n=S.getAllBuildingMeshes(e);self.postMessage({type:"building-lod-changed",meshData:n,lod:e})}break;case"regenerate-with-zone":if(w&&S&&v){if(t.zoneRequest){const r=t.zoneRequest;w.paintZone(r,v)}S.clear();const e=w.getParcels(),n=S.generateBuildings(e,D),s=t.lod!==void 0?t.lod:1,i=S.getAllBuildingMeshes(s);self.postMessage({type:"buildings-regenerated",buildings:n.map(r=>({id:r.id,parcelId:r.parcelId,height:r.height,floorCount:r.floorCount,style:r.style,roofType:r.roofType})),meshData:i,lod:s,parcels:w.getParcelsTypedArrays()})}break;default:console.warn("Unknown message type:",t.type)}};
